{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"GBQ - 0.3.0 Example from gbq import BigQuery # BigQuery project id as listed in the Google Developers Console. project_id = 'project_id' # BigQuery dataset id as listed in the Google Developers Console. dataset_id = 'dataset_id' # BigQuery table/view id as listed in the Google Developers Console. structure_id = 'structure_id' # BigQuery structure definition as defined in the Google Developers Console. json_schema = { \"type\" : \"table\" , \"schema\" : [{ \"id\" : \"integer\" }]} # Service account email address as listed in the Google Developers Console. svc_account = '{\"type\": \"service_account\", \"project_id\": \"project_id\"}' bq = BigQuery ( svc_account = svc_account , project = project_id ) bq . create_or_update_structure ( project_id , dataset_id , structure_id , json_schema ) Where to Start? To learn the basics of how to start using gbq , read the Getting Started page. Detailed Documentation To learn more about the various ways gbq can be used, read the Usage Guide page.","title":"Overview"},{"location":"#gbq-030","text":"","title":"GBQ - 0.3.0"},{"location":"#example","text":"from gbq import BigQuery # BigQuery project id as listed in the Google Developers Console. project_id = 'project_id' # BigQuery dataset id as listed in the Google Developers Console. dataset_id = 'dataset_id' # BigQuery table/view id as listed in the Google Developers Console. structure_id = 'structure_id' # BigQuery structure definition as defined in the Google Developers Console. json_schema = { \"type\" : \"table\" , \"schema\" : [{ \"id\" : \"integer\" }]} # Service account email address as listed in the Google Developers Console. svc_account = '{\"type\": \"service_account\", \"project_id\": \"project_id\"}' bq = BigQuery ( svc_account = svc_account , project = project_id ) bq . create_or_update_structure ( project_id , dataset_id , structure_id , json_schema )","title":"Example"},{"location":"#where-to-start","text":"To learn the basics of how to start using gbq , read the Getting Started page.","title":"Where to Start?"},{"location":"#detailed-documentation","text":"To learn more about the various ways gbq can be used, read the Usage Guide page.","title":"Detailed Documentation"},{"location":"changelog/","text":"../CHANGELOG.md","title":"Changelog"},{"location":"development-guide/","text":"Development Guide Welcome! Thank you for wanting to make the project better. This section provides an overview on how repository structure and how to work with the code base. Before you dive into this, it is best to read: The Code of Conduct The Contributing guide Docker The GBQ project uses Docker to ease setting up a consistent development environment. The Docker documentation has details on how to install docker on your computer. Once that is configured, the test suite can be run locally: docker-compose run --rm test If you want to be able to execute code in the container: docker-compose run --rm devbox ( your code here ) In the devbox environment you'll be able to enter a python shell and import gbq or any dependencies. Debugging The docker container has pdb++ install that can be used as a debugger. (However, you are welcome to set up a different debugger if you would like.) This allows you to easily create a breakpoint anywhere in the code. def my_function (): breakpoint () ... When your the code, you will drop into an interactive pdb++ debugger. See the documentation on pdb and pdb++ for more information. Testing You'll be unable to merge code unless the linting and tests pass. You can run these in your container via: docker-compose run --rm test This will run the same tests, linting, and code coverage that are run by the CI pipeline. The only difference is that, when run locally, black and isort are configured to automatically correct issues they detect. Generally we should endeavor to write tests for every feature. Every new feature branch should increase the test coverage rather than decreasing it. We use pytest as our testing framework. Stages To customize / override a specific testing stage, please read the documentation specific to that tool: PyTest MyPy Black Isort Flake8 Bandit Building the Library gbq is PEP 517 compliant. build is used as the frontend tool for building the library. Setuptools is used as the build backend. setup.cfg contains the library metadata. A setup.py is also included to support an editable install. Requirements requirements.lock - Lists all direct dependencies (packages imported by the library). requirements-test.txt - Lists all direct dependencies needed for development. This primarily covers dependencies needed to run the test suite & lints. Publishing a New Version Once the package is ready to be released, there are a few things that need to be done: Start with a local clone of the repo on the default branch with a clean working tree. Run the version bump script with the appropriate part name ( major , minor , or patch ). Example: docker-compose run --rm bump minor This wil create a new branch, updates all affected files with the new version, and commit the changes to the branch. Push the new branch to create a new pull request. Get the pull request approved. Merge the pull request to the default branch. Merging the pull request will trigger a GitHub Action that will create a new release. The creation of this new release will trigger a GitHub Action that will to build a wheel & a source distributions of the package and push them to PyPI . Warning The action that uploads the files to PyPI will not run until a repository maintainer acknowledges that the job is ready to run. This is to keep the PyPI publishing token secure. Otherwise, any job would have access to the token. In addition to uploading the files to PyPI, the documentation website will be updated to include the new version. If the new version is a full release, it will be made the new latest version. Continuous Integration Pipeline The Continuous Integration (CI) Pipeline runs to confirm that the repository is in a good state. It will run when someone creates a pull request or when they push new commits to the branch for an existing pull request. The pipeline runs multiple different jobs that helps verify the state of the code. This same pipeline also runs on the default branch when a maintainer merges a pull request. Lints The first set of jobs that run as part of the CI pipline are linters that perform static analysis on the code. This includes: MyPy , Black , Isort , Flake8 , and Bandit . Tests The next set of jobs run the unit tests using PyTest . The pipeline runs the tests cases across each supported version of Python to ensure compatibility. For each run of the test cases, the job will record the test results and code coverage information. The pipeline uploads the code coverage information to CodeCov to ensure that a pull request doesn't significantly reduce the total code coverage percentage or introduce a large amount of code that is untested. Distribution Verification The next set of jobs build the wheel distribution, installs in into a virtual environment, and then runs Python to import the library version. This works as a smoke test to ensure that the library can be packaged correctly and used. The pipeline runs the tests cases across each supported version of Python to ensure compatibility.","title":"Development Guide"},{"location":"development-guide/#development-guide","text":"Welcome! Thank you for wanting to make the project better. This section provides an overview on how repository structure and how to work with the code base. Before you dive into this, it is best to read: The Code of Conduct The Contributing guide","title":"Development Guide"},{"location":"development-guide/#docker","text":"The GBQ project uses Docker to ease setting up a consistent development environment. The Docker documentation has details on how to install docker on your computer. Once that is configured, the test suite can be run locally: docker-compose run --rm test If you want to be able to execute code in the container: docker-compose run --rm devbox ( your code here ) In the devbox environment you'll be able to enter a python shell and import gbq or any dependencies.","title":"Docker"},{"location":"development-guide/#debugging","text":"The docker container has pdb++ install that can be used as a debugger. (However, you are welcome to set up a different debugger if you would like.) This allows you to easily create a breakpoint anywhere in the code. def my_function (): breakpoint () ... When your the code, you will drop into an interactive pdb++ debugger. See the documentation on pdb and pdb++ for more information.","title":"Debugging"},{"location":"development-guide/#testing","text":"You'll be unable to merge code unless the linting and tests pass. You can run these in your container via: docker-compose run --rm test This will run the same tests, linting, and code coverage that are run by the CI pipeline. The only difference is that, when run locally, black and isort are configured to automatically correct issues they detect. Generally we should endeavor to write tests for every feature. Every new feature branch should increase the test coverage rather than decreasing it. We use pytest as our testing framework.","title":"Testing"},{"location":"development-guide/#stages","text":"To customize / override a specific testing stage, please read the documentation specific to that tool: PyTest MyPy Black Isort Flake8 Bandit","title":"Stages"},{"location":"development-guide/#building-the-library","text":"gbq is PEP 517 compliant. build is used as the frontend tool for building the library. Setuptools is used as the build backend. setup.cfg contains the library metadata. A setup.py is also included to support an editable install.","title":"Building the Library"},{"location":"development-guide/#requirements","text":"requirements.lock - Lists all direct dependencies (packages imported by the library). requirements-test.txt - Lists all direct dependencies needed for development. This primarily covers dependencies needed to run the test suite & lints.","title":"Requirements"},{"location":"development-guide/#publishing-a-new-version","text":"Once the package is ready to be released, there are a few things that need to be done: Start with a local clone of the repo on the default branch with a clean working tree. Run the version bump script with the appropriate part name ( major , minor , or patch ). Example: docker-compose run --rm bump minor This wil create a new branch, updates all affected files with the new version, and commit the changes to the branch. Push the new branch to create a new pull request. Get the pull request approved. Merge the pull request to the default branch. Merging the pull request will trigger a GitHub Action that will create a new release. The creation of this new release will trigger a GitHub Action that will to build a wheel & a source distributions of the package and push them to PyPI . Warning The action that uploads the files to PyPI will not run until a repository maintainer acknowledges that the job is ready to run. This is to keep the PyPI publishing token secure. Otherwise, any job would have access to the token. In addition to uploading the files to PyPI, the documentation website will be updated to include the new version. If the new version is a full release, it will be made the new latest version.","title":"Publishing a New Version"},{"location":"development-guide/#continuous-integration-pipeline","text":"The Continuous Integration (CI) Pipeline runs to confirm that the repository is in a good state. It will run when someone creates a pull request or when they push new commits to the branch for an existing pull request. The pipeline runs multiple different jobs that helps verify the state of the code. This same pipeline also runs on the default branch when a maintainer merges a pull request.","title":"Continuous Integration Pipeline"},{"location":"development-guide/#lints","text":"The first set of jobs that run as part of the CI pipline are linters that perform static analysis on the code. This includes: MyPy , Black , Isort , Flake8 , and Bandit .","title":"Lints"},{"location":"development-guide/#tests","text":"The next set of jobs run the unit tests using PyTest . The pipeline runs the tests cases across each supported version of Python to ensure compatibility. For each run of the test cases, the job will record the test results and code coverage information. The pipeline uploads the code coverage information to CodeCov to ensure that a pull request doesn't significantly reduce the total code coverage percentage or introduce a large amount of code that is untested.","title":"Tests"},{"location":"development-guide/#distribution-verification","text":"The next set of jobs build the wheel distribution, installs in into a virtual environment, and then runs Python to import the library version. This works as a smoke test to ensure that the library can be packaged correctly and used. The pipeline runs the tests cases across each supported version of Python to ensure compatibility.","title":"Distribution Verification"},{"location":"getting-started/","text":"Getting Started Installation To install gbq , simply run this simple command in your terminal of choice: python -m pip install gbq Introduction gbq was developed internally at Wayfair to be used a CD pipeline to create/update tables on Google BigQuery. At Wayfair gbq is used in a with a BigQuery plugin which reads json schema files and updates the schemas on Google BigQuery. What's Next? TODO","title":"Getting Started"},{"location":"getting-started/#getting-started","text":"","title":"Getting Started"},{"location":"getting-started/#installation","text":"To install gbq , simply run this simple command in your terminal of choice: python -m pip install gbq","title":"Installation"},{"location":"getting-started/#introduction","text":"gbq was developed internally at Wayfair to be used a CD pipeline to create/update tables on Google BigQuery. At Wayfair gbq is used in a with a BigQuery plugin which reads json schema files and updates the schemas on Google BigQuery.","title":"Introduction"},{"location":"getting-started/#whats-next","text":"TODO","title":"What's Next?"}]}